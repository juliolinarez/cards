# GitLab CI/CD for Rails - Complete & Corrected Version

# Usa una imagen de Ruby estable.
image: ruby:3.3

# Variables globales para todos los jobs.
# Nota: No se define DATABASE_URL para permitir que parallel_test funcione correctamente.
variables:
  POSTGRES_HOST: postgres
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: ""
  POSTGRES_HOST_AUTH_METHOD: trust
  RAILS_ENV: test
  BUNDLE_PATH: "vendor/bundle"

# El cachÃ© acelera el job 'install' en ejecuciones subsiguientes.
cache:
  key:
    files:
      - Gemfile.lock
  paths:
    - vendor/bundle/

stages:
  - install_dependencies # Etapa 1: Instalar todo
  - test                 # Etapa 2: Probar y cobertura
  - quality              # Etapa 3: AnÃ¡lisis de calidad

# --- STAGE 1: INSTALL DEPENDENCIES ---
install:
  stage: install_dependencies
  script:
    - apt-get update -qq && apt-get install -y -qq nodejs postgresql-client libpq-dev
    - gem install bundler --no-document
    - bundle config set --local path "${BUNDLE_PATH}"
    - bundle install --jobs $(nproc)
  # Guarda las gemas instaladas como un artefacto para los siguientes stages.
  artifacts:
    paths:
      - vendor/bundle/
    expire_in: 1 hour

# --- STAGE 2: TEST ---
# Los jobs en este stage dependen de 'install' y usan sus artefactos.

test:
  stage: test
  services:
    - name: postgres:15-alpine
      alias: postgres
  needs:
    - job: install
      artifacts: true
  parallel: 2
  script:
    - bundle exec rails db:create
    - bundle exec rails db:migrate
    - echo "Ejecutando tests en job ${CI_NODE_INDEX} de ${CI_NODE_TOTAL}..."
    - bundle exec parallel_test -n ${CI_NODE_TOTAL} --type rspec --only-group ${CI_NODE_INDEX} spec/
    - |
      if [ "${CI_NODE_INDEX}" == "1" ]; then
        ruby -e "
        require 'json'
        if File.exist?('coverage/.resultset.json')
          coverage_data = JSON.parse(File.read('coverage/.resultset.json'))
          if coverage_data && coverage_data['RSpec'] && coverage_data['RSpec']['coverage']
            total_lines = 0
            covered_lines = 0

            coverage_data['RSpec']['coverage'].each do |file, lines|
              lines.each do |line_coverage|
                if line_coverage != nil
                  total_lines += 1
                  covered_lines += 1 if line_coverage > 0
                end
              end
            end

            if total_lines > 0
              percentage = (covered_lines.to_f / total_lines * 100).round(2)
              puts \"Coverage: #{percentage}% (#{covered_lines}/#{total_lines} lines)\"
              if percentage < 70
                puts \"ERROR: Coverage #{percentage}% is below minimum requirement of 70%\"
                exit 1
              else
                puts \"SUCCESS: Coverage #{percentage}% meets requirement\"
              end
            else
              puts 'No coverage data lines found'
              exit 1
            end
          else
            puts 'Invalid coverage data structure'
            exit 1
          end
        else
          puts 'No coverage data found'
          exit 1
        end
        "
      fi
  coverage: '/\(\d+.\d+\%\) covered/'
  artifacts:
    paths:
      - coverage/
      - tmp/rspec.xml # Asumiendo que RSpec ahora guarda un solo archivo combinado.
    reports:
      junit: tmp/rspec.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/coverage.xml
    expire_in: 1 week
    when: always


rubocop:
  stage: quality
  needs:
    - job: install
      artifacts: true
  script:
    - bundle exec rubocop --format progress --format json --out rubocop-report.json
  artifacts:
    reports:
      codequality: rubocop-report.json
    expire_in: 1 week


